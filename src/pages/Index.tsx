
import React, { useState, useEffect } from 'react';
import { toast } from "@/components/ui/use-toast";
import Navbar from "@/components/Navbar";
import Sidebar from "@/components/Sidebar";
import Chat from "@/components/Chat";
import { Tool, Message, HistoryItem } from "@/lib/types";

// Mock data for preview purposes
// In a real application, this would come from API calls
const mockTools: Tool[] = [
  {
    name: "weatherLookup",
    description: "Get the current weather for a specified location",
    parameters: {
      location: {
        type: "string",
        description: "The city and state/country, e.g. 'San Francisco, CA'",
        required: true
      },
      units: {
        type: "string",
        description: "Temperature units",
        enum: ["celsius", "fahrenheit"],
        default: "celsius"
      }
    }
  },
  {
    name: "stockPrice",
    description: "Get the current stock price for a ticker symbol",
    parameters: {
      symbol: {
        type: "string",
        description: "The stock ticker symbol, e.g. 'AAPL'",
        required: true
      }
    }
  },
  {
    name: "webSearch",
    description: "Search the web for information",
    parameters: {
      query: {
        type: "string",
        description: "The search query",
        required: true
      },
      numResults: {
        type: "number",
        description: "Number of results to return",
        default: 5
      }
    }
  }
];

const Index = () => {
  const [isConnected, setIsConnected] = useState(true);
  const [tools, setTools] = useState<Tool[]>(mockTools);
  const [messages, setMessages] = useState<Message[]>([]);
  const [history, setHistory] = useState<HistoryItem[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  // In a real app, we would connect to the MCP server on mount
  useEffect(() => {
    // Mock successful connection
    setIsConnected(true);
    setTools(mockTools);

    // Show a welcome toast
    toast({
      title: "Welcome to MCP Integration",
      description: "Connected to the Model Context Protocol server",
    });
  }, []);

  // Handle sending a message
  const handleSendMessage = (text: string) => {
    // Add user message
    const userMessage: Message = {
      id: Date.now().toString(),
      text,
      sender: 'user',
      timestamp: new Date().toISOString()
    };
    
    setMessages(prev => [...prev, userMessage]);
    
    // Show "thinking" indicator
    const thinkingId = (Date.now() + 1).toString();
    setMessages(prev => [
      ...prev, 
      { id: thinkingId, text: '', sender: 'assistant', thinking: true }
    ]);
    
    // Simulate response after a delay
    setTimeout(() => {
      // Remove thinking indicator
      setMessages(prev => prev.filter(msg => msg.id !== thinkingId));
      
      // Randomly decide if we'll use a tool or not
      const useTool = Math.random() > 0.5;
      
      if (useTool && tools.length > 0) {
        // Choose a random tool
        const tool = tools[Math.floor(Math.random() * tools.length)];
        
        // Create response with tool info
        const assistantMessage: Message = {
          id: (Date.now() + 2).toString(),
          text: `Based on your query, I found some information using the ${tool.name} tool.`,
          sender: 'assistant',
          timestamp: new Date().toISOString(),
          toolInfo: {
            toolName: tool.name,
            toolReasoning: `I used this tool because your query seemed to be asking for ${tool.description.toLowerCase()}`,
            toolResult: { status: "success", data: { result: "Mock tool result data" } }
          }
        };
        
        setMessages(prev => [...prev, assistantMessage]);
      } else {
        // Regular response without tool
        const assistantMessage: Message = {
          id: (Date.now() + 2).toString(),
          text: `Thank you for your message. This is a simulated response from the AI assistant. In a real application, this would be generated by an LLM. Your query was: "${text}"`,
          sender: 'assistant',
          timestamp: new Date().toISOString()
        };
        
        setMessages(prev => [...prev, assistantMessage]);
      }
      
      // Add to history
      const historyItem: HistoryItem = {
        id: Date.now().toString(),
        query: text,
        response: "This is a simulated response (truncated for history view)",
        timestamp: new Date().toISOString()
      };
      
      setHistory(prev => [historyItem, ...prev]);
    }, 2000);
  };

  // Clear chat
  const handleClearChat = () => {
    setMessages([]);
    toast({
      title: "Chat cleared",
      description: "All messages have been cleared from this conversation",
    });
  };

  // Retry connection
  const handleRetryConnection = () => {
    setIsLoading(true);
    
    // Simulate connection attempt
    setTimeout(() => {
      setIsConnected(true);
      setIsLoading(false);
      
      toast({
        title: "Connection restored",
        description: "Successfully reconnected to the MCP server",
      });
    }, 1500);
  };

  return (
    <div className="min-h-screen flex flex-col">
      <Navbar isConnected={isConnected} onRetryConnection={handleRetryConnection} />
      
      <div className="flex flex-1 overflow-hidden">
        <div className="hidden md:block">
          <Sidebar 
            tools={tools} 
            history={history} 
            isLoading={isLoading} 
          />
        </div>
        
        <Chat 
          messages={messages}
          onSendMessage={handleSendMessage}
          onClearChat={handleClearChat}
          isConnected={isConnected}
        />
      </div>
    </div>
  );
};

export default Index;
